(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{376:function(t,s,a){"use strict";a.r(s);var e=a(25),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"websocket-api-描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket-api-描述"}},[t._v("#")]),t._v(" WebSocket API 描述")]),t._v(" "),a("p",[a("strong",[t._v("注：本页描述的是插件作为 WebSocket 服务端的情况，其它通信方式请见 "),a("a",{attrs:{href:"CommunicationMethods"}},[t._v("通信方式")]),t._v("。")])]),t._v(" "),a("p",[t._v("除了 HTTP 方式调用 API、接收事件上报，目前插件还支持 WebSocket。使用 WebSocket 时，只需要你的机器人程序单方面的向插件建立连接，即可调用 API 和接收事件推送。数据全部使用 JSON 格式传递。")]),t._v(" "),a("p",[t._v("要使用 WebSocket，首先需要在配置文件中填写如下配置：")]),t._v(" "),a("div",{staticClass:"language-ini extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ini"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ws_host")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" 0.0.0.0  # 监听的 IP")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ws_port")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" 6700  # 监听的端口")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("use_ws")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" yes  # 启用 WebSocket 服务端")]),t._v("\n")])])]),a("p",[t._v("重启插件后，便启动了 WebSocket 服务器。")]),t._v(" "),a("p",[t._v("插件提供了两个接口 "),a("code",[t._v("/api/")]),t._v(" 和 "),a("code",[t._v("/event/")]),t._v("，分别用于调用 API 和推送事件。除此之外，还有 "),a("code",[t._v("/")]),t._v(" 接口，用于在同一条连接上做上述两件事，这个接口相当于 "),a("code",[t._v("/api/")]),t._v(" 和 "),a("code",[t._v("/event/")]),t._v(" 的合并，下面不再单独说明。")]),t._v(" "),a("p",[t._v("如果配置文件中填写了 "),a("code",[t._v("access_token")]),t._v("，则建立连接时需要在请求头中加入验证头：")]),t._v(" "),a("div",{staticClass:"language-http extra-class"},[a("pre",{pre:!0,attrs:{class:"language-http"}},[a("code",[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Authorization:")]),t._v(" Bearer kSLuTF2GC2Q4q4ugm3\n")])])]),a("p",[t._v("或者在 URI 中指定，如 "),a("code",[t._v("/api/?access_token=kSLuTF2GC2Q4q4ugm3")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"api-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-接口"}},[t._v("#")]),t._v(" "),a("code",[t._v("/api/")]),t._v(" 接口")]),t._v(" "),a("p",[t._v("连接此接口后，向插件发送如下结构的 JSON 对象，即可调用相应的 API：")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"action"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"send_private_msg"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"params"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"user_id"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123456")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"message"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"你好"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这里的 "),a("code",[t._v("action")]),t._v(" 参数用于指定要调用的 API，具体支持的 API 可以参考 "),a("a",{attrs:{href:"API#api-%E5%88%97%E8%A1%A8"}},[t._v("API 列表")]),t._v("。"),a("code",[t._v("params")]),t._v(" 用于传入参数，如果要调用的 API 不需要参数，则可以不加。")]),t._v(" "),a("p",[t._v("客户端向插件发送 JSON 之后，插件会往回发送一个调用结果，结构和 "),a("a",{attrs:{href:"API#%E5%93%8D%E5%BA%94%E8%AF%B4%E6%98%8E"}},[t._v("响应说明")]),t._v(" 是一样的，唯一的区别在于，调用 HTTP 接口时，通过 HTTP 状态码反应的错误情况，被移动到响应 JSON 的 "),a("code",[t._v("retcode")]),t._v(" 字段，例如，HTTP 接口返回 404 的情况，对应到 WebSocket 的回复，是：")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"status"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"retcode"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1404")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"data"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token null keyword"}},[t._v("null")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("下面是 "),a("code",[t._v("retcode")]),t._v(" 和 HTTP 接口的状态码的对照：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("code",[t._v("retcode")])]),t._v(" "),a("th",[t._v("HTTP 接口中的状态码")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("1400")]),t._v(" "),a("td",[t._v("400")])]),t._v(" "),a("tr",[a("td",[t._v("1401")]),t._v(" "),a("td",[t._v("401")])]),t._v(" "),a("tr",[a("td",[t._v("1403")]),t._v(" "),a("td",[t._v("403")])]),t._v(" "),a("tr",[a("td",[t._v("1404")]),t._v(" "),a("td",[t._v("404")])])])]),t._v(" "),a("p",[t._v("目前实际上 "),a("code",[t._v("1401")]),t._v(" 和 "),a("code",[t._v("1403")]),t._v(" 并不会真的返回，因为如果建立连接时鉴权失败，连接会直接断开，根本不可能进行到后面的接口调用阶段。")]),t._v(" "),a("p",[t._v("对于 "),a("code",[t._v("/api/")]),t._v(" 接口，你可以保持连接，也可以每次请求是重新建立连接，区别不是很大。")]),t._v(" "),a("h2",{attrs:{id:"event-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-接口"}},[t._v("#")]),t._v(" "),a("code",[t._v("/event/")]),t._v(" 接口")]),t._v(" "),a("p",[t._v("连接此接口后，插件会在收到事件后推送至客户端，推送的格式和 HTTP POST 方式上报的完全一致，见 "),a("a",{attrs:{href:"Post#%E4%B8%8A%E6%8A%A5%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"}},[t._v("上报数据格式")]),t._v("，事件列表见 "),a("a",{attrs:{href:"Post#%E4%BA%8B%E4%BB%B6%E5%88%97%E8%A1%A8"}},[t._v("事件列表")]),t._v("。")]),t._v(" "),a("p",[t._v("与 HTTP 上报不同的是，WebSocket 推送不会对数据进行签名（即 HTTP 上报中的 "),a("code",[t._v("X-Signature")]),t._v(" 请求头在这里没有等价的东西），并且也不会处理响应数据。如果对事件进行处理的时候需要调用接口，请使用 HTTP 接口或 WebSocket 的 "),a("code",[t._v("/api/")]),t._v(" 接口。")]),t._v(" "),a("p",[t._v("此外，这个接口和配置文件的 "),a("code",[t._v("post_url")]),t._v(" 不冲突，如果开启了 WebSocket 支持，同时 "),a("code",[t._v("post_url")]),t._v(" 也不为空的话，插件会先通过 HTTP 上报给 "),a("code",[t._v("post_url")]),t._v("，在处理完它的响应后，向所有已连接了 "),a("code",[t._v("/event/")]),t._v(" 的 WebSocket 客户端推送事件。")])])}),[],!1,null,null,null);s.default=v.exports}}]);